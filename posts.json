[
  {
    "id": 1,
    "slug": "react-hooks-guide",
    "title": "Полное руководство по React Hooks",
    "excerpt": "Узнайте, как использовать React Hooks для создания функциональных компонентов с состоянием.",
    "date": "2025-01-15",
    "readTime": 8,
    "tags": ["React", "JavaScript", "Hooks"],
    "content": "<h2>Введение</h2><p>React Hooks позволили писать компоненты как функции и при этом использовать состояние, эффекты и другие возможности React без классов.</p><p>Хуки - это функции, которые принято узнавать по префиксу <code>use</code>, и они вызываются внутри React-компонентов (или внутри ваших кастомных хуков).</p><p>В этом руководстве разобраны базовые хуки (<code>useState</code>, <code>useEffect</code>), а также практичные дополнения (<code>useRef</code>, <code>useMemo</code>, <code>useCallback</code>, <code>useContext</code>, <code>useReducer</code>) и паттерны для реальных проектов.</p>\n\n<h2>Правила хуков</h2><p>Чтобы хуки работали корректно, важно соблюдать два базовых правила.</p><ul><li>Вызывайте хуки только на верхнем уровне компонента - не внутри условий, циклов и вложенных функций, чтобы порядок вызовов был одинаковым на каждом рендере.</li><li>Вызывайте хуки только из React-функций: функциональных компонентов или кастомных хуков, а не из «обычных» JS-функций.</li></ul><p>Для автоматической проверки используют <code>eslint-plugin-react-hooks</code>, который включает правила <code>rules-of-hooks</code> и <code>exhaustive-deps</code>. </p>\n\n<h2>useState Hook</h2><p><code>useState</code> - хук, который добавляет переменную состояния в функциональный компонент и возвращает пару: текущее значение и функцию обновления. </p><p>Мини-шаблон выглядит так: <code>const [value, setValue] = useState(initialValue)</code>. </p>\n\n<h3>Базовый пример</h3>\n<pre><code class=\"language-jsx\">import { useState } from 'react';\n\nexport function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Clicks: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Plus&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<h3>Практические советы</h3><ul><li>Если новое состояние зависит от предыдущего, используйте функциональное обновление, чтобы избежать проблем со «старыми» значениями при серии обновлений. </li><li>Храните в состоянии только то, что участвует в рендере, а значения «для логики» (таймеры, счетчики кликов в обработчиках) часто удобнее хранить в <code>useRef</code>. </li></ul>\n\n<h2>useEffect Hook</h2><p><code>useEffect</code> нужен для побочных эффектов в функциональных компонентах (например, загрузка данных, подписки, ручные обращения к DOM и т.д.). </p><p>По умолчанию эффект запускается после первого рендера и после каждого последующего обновления. </p><p>Если эффект возвращает функцию, React использует её как механизм очистки (cleanup). </p>\n\n<h3>Зависимости и очистка</h3><ul><li>React выполняет очистку эффекта при размонтировании компонента, а также очищает эффект предыдущего рендера перед запуском следующего, что помогает избегать утечек и несоответствий. </li><li>Чтобы пропускать лишние запуски эффекта, передавайте массив зависимостей вторым аргументом <code>useEffect(..., [deps])</code>. </li><li>Если в эффекте используются значения из области видимости компонента (props/state), их нужно учитывать в зависимостях, иначе можно получить баги со «старыми» значениями. </li></ul>\n\n<h3>Пример: подписка + cleanup</h3>\n<pre><code class=\"language-jsx\">import { useEffect } from 'react';\n\nexport function ResizeLogger() {\n  useEffect(() =&gt; {\n    const onResize = () =&gt; console.log('resize', window.innerWidth);\n    window.addEventListener('resize', onResize);\n\n    return () =&gt; {\n      window.removeEventListener('resize', onResize);\n    };\n  }, []);\n\n  return &lt;div&gt;Open console and resize window&lt;/div&gt;;\n}</code></pre>\n\n<h3>Пример: загрузка данных (с отменой)</h3>\n<pre><code class=\"language-jsx\">import { useEffect, useState } from 'react';\n\nexport function User({ id }) {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    const controller = new AbortController();\n\n    (async () =&gt; {\n      try {\n        setError(null);\n        const res = await fetch(`/api/users/${id}`, { signal: controller.signal });\n        if (!res.ok) throw new Error('Request failed');\n        setData(await res.json());\n      } catch (e) {\n        if (e.name !== 'AbortError') setError(e);\n      }\n    })();\n\n    return () =&gt; controller.abort();\n  }, [id]);\n\n  if (error) return &lt;p&gt;Error&lt;/p&gt;;\n  if (!data) return &lt;p&gt;Loading...&lt;/p&gt;;\n  return &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;;\n}</code></pre>\n\n<h3>Частая ловушка: «useEffect срабатывает дважды»</h3><p>В dev-режиме при включённом Strict Mode можно заметить повторные срабатывания эффектов на старте, и это обычно связано с дополнительными проверками корректности побочных эффектов и очистки. </p>\n\n<h2>useRef Hook</h2><p><code>useRef</code> позволяет хранить значение, которое должно переживать ререндеры, но само по себе не обязано участвовать в отображении. </p><p><code>useRef(initialValue)</code> возвращает объект с полем <code>current</code>, которое можно менять без запуска ререндера. </p>\n\n<h3>Пример: хранение id таймера</h3>\n<pre><code class=\"language-jsx\">import { useEffect, useRef, useState } from 'react';\n\nexport function Stopwatch() {\n  const [seconds, setSeconds] = useState(0);\n  const intervalRef = useRef(null);\n\n  useEffect(() =&gt; {\n    intervalRef.current = setInterval(() =&gt; setSeconds(s =&gt; s + 1), 1000);\n    return () =&gt; clearInterval(intervalRef.current);\n  }, []);\n\n  return &lt;div&gt;{seconds}s&lt;/div&gt;;\n}</code></pre>\n\n<h2>useMemo и useCallback</h2><p><code>useMemo</code> кэширует результат вычисления между ререндерами, пока зависимости не изменятся. </p><p><code>useCallback</code> кэширует (стабилизирует) ссылку на функцию между ререндерами, пока зависимости не изменятся. </p>\n\n<h3>Когда это реально нужно</h3><ul><li><code>useMemo</code> полезен для дорогих вычислений или чтобы не создавать новый объект/массив на каждый рендер, если это ломает оптимизации ниже по дереву. </li><li><code>useCallback</code> полезен, когда вы передаёте колбэк в дочерний компонент (особенно если он мемоизирован) или используете колбэк в зависимостях другого хука. </li></ul>\n\n<h3>Пример: стабилизация обработчика</h3>\n<pre><code class=\"language-jsx\">import { useCallback, useState } from 'react';\n\nexport function Form() {\n  const [value, setValue] = useState('');\n\n  const handleSubmit = useCallback((e) =&gt; {\n    e.preventDefault();\n    // send(value)\n  }, [value]);\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt;\n      &lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}</code></pre>\n\n<h2>useContext Hook</h2><p><code>useContext</code> читает и «подписывает» компонент на значение контекста, которое передаёт ближайший Provider выше по дереву. </p><p>Если Provider отсутствует, возвращается <code>defaultValue</code>, указанный при <code>createContext(defaultValue)</code>. </p><p>Когда значение контекста меняется, React автоматически перерендерит компоненты, которые его читают. </p>\n\n<h3>Мини-пример</h3>\n<pre><code class=\"language-jsx\">import { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext('light');\n\nfunction Button() {\n  const theme = useContext(ThemeContext);\n  return &lt;button className={theme}&gt;OK&lt;/button&gt;;\n}\n\nexport function App() {\n  return (\n    &lt;ThemeContext.Provider value=\"dark\"&gt;\n      &lt;Button /&gt;\n    &lt;/ThemeContext.Provider&gt;\n  );\n}</code></pre>\n\n<h2>useReducer Hook</h2><p><code>useReducer</code> удобно использовать, когда логика обновления состояния становится сложной (много полей, много типов событий, цепочки переходов). </p><p>Паттерн похож на Redux: есть <code>reducer(state, action) =&gt; newState</code> и <code>dispatch(action)</code>, который запускает обновление. </p>\n\n<h3>Пример: счётчик на reducer</h3>\n<pre><code class=\"language-jsx\">import { useReducer } from 'react';\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'inc':\n      return { count: state.count + 1 };\n    case 'dec':\n      return { count: state.count - 1 };\n    default:\n      throw new Error('Unknown action');\n  }\n}\n\nexport function CounterReducer() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 });\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state.count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; dispatch({ type: 'dec' })}&gt;-&lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch({ type: 'inc' })}&gt;+&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n\n<h2>Кастомные хуки</h2><p>Кастомный хук - это функция, которая переиспользует логику на базе других хуков и помогает делить код по смыслу, а не по «жизненным циклам». </p><p>Обычно кастомные хуки начинаются с <code>use</code> и могут возвращать данные/методы, которые удобно использовать в компонентах. </p>\n\n<h3>Пример: useLocalStorage</h3>\n<pre><code class=\"language-jsx\">import { useEffect, useState } from 'react';\n\nexport function useLocalStorage(key, initialValue) {\n  const [value, setValue] = useState(() =&gt; {\n    const raw = localStorage.getItem(key);\n    return raw ? JSON.parse(raw) : initialValue;\n  });\n\n  useEffect(() =&gt; {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n\n  return [value, setValue];\n}</code></pre>\n\n<h2>Чеклист: частые ошибки</h2><ul><li>Не вызывайте хуки условно - условие переносите внутрь эффекта/логики, иначе React «потеряет» соответствие состояния порядку вызовов. </li><li>В <code>useEffect</code> не забывайте cleanup для подписок/таймеров/обработчиков событий, иначе получите утечки и странные баги при обновлениях и размонтировании. </li><li>Не пытайтесь «лечить» неправильные зависимости в эффекте удалением значений из массива зависимостей - чаще это маскирует проблему со старыми значениями. </li><li>Не используйте <code>useMemo</code>/<code>useCallback</code> «везде подряд»: это инструмент оптимизации, который имеет смысл, когда есть реальная причина стабилизировать ссылку или кэшировать дорогой расчёт. </li></ul>"
  },
  {
    "id": 2,
    "slug": "typescript-best-practices",
    "title": "Лучшие практики TypeScript",
    "excerpt": "Как правильно использовать TypeScript для масштабируемых приложений.",
    "date": "2025-01-10",
    "readTime": 12,
    "tags": ["TypeScript", "Best Practices"],
    "content": "<h2>Зачем нужен TypeScript?</h2><p>TypeScript даёт статическую типизацию и проверки на этапе разработки, чтобы раньше находить ошибки, которые в JavaScript проявились бы только во время выполнения.</p><p>Основная идея практик ниже - сделать типы «источником правды»: типы описывают модель данных, а компилятор и линтер помогают удерживать код в согласованном состоянии по мере роста проекта.</p>\n\n<h2>Типы и интерфейсы</h2><p>В TypeScript есть два близких инструмента для описания формы объектов: <code>interface</code> и <code>type</code> (type alias), и оба широко применяются в реальных кодовых базах.</p><p>Интерфейсы умеют описывать не только объектные типы, но и функциональные типы через <em>call signature</em> (сигнатуру вызова).</p>\n\n<h3>Когда чаще выбирают interface</h3><ul><li><strong>Расширение</strong> через <code>extends</code> хорошо читается, когда нужно «наращивать» контракт объекта по мере усложнения домена.</li><li>Интерфейсы поддерживают «слияние объявлений» (declaration merging): если в одной области видимости есть несколько деклараций с одинаковым именем, компилятор объединяет их в одну./li></ul>\n\n<h3>Когда чаще выбирают type</h3><ul><li>Type alias удобно использовать для объединений (union) и пересечений (intersection), потому что эти конструкции - часть повседневной типизации.</li><li>Type alias хорошо подходит для композиции типов через <code>|</code> и <code>&amp;</code>, когда нужно собрать тип из нескольких вариантов или признаков.</li></ul>\n\n<h3>Важно про конфликты при объединении</h3><p>TypeScript отдельно подчёркивает, что расширение интерфейсов и пересечение типов решают похожую задачу, но по-разному обрабатывают конфликты свойств, и это часто влияет на выбор подхода.</p>\n\n<h2>Моделирование домена (масштабируемость)</h2><p>Масштабируемые приложения обычно выигрывают от точных моделей данных: вместо «широких» типов лучше описывать реальные варианты входных/выходных данных через union-типы.</p><p>Union-типы в TypeScript записываются через вертикальную черту <code>|</code> и означают «значение может быть одним из нескольких типов». [web:112]</p>\n\n<h3>Пример: union + сужение типов (narrowing)</h3><p>TypeScript умеет «сужать» типы (narrowing), используя знакомые JavaScript-проверки, чтобы внутри ветки кода работать с более конкретным типом.</p>\n<pre><code class=\"language-ts\">type ApiResult = { ok: true; data: string } | { ok: false; error: string };\n\nfunction render(result: ApiResult) {\n  if (result.ok) {\n    // result: { ok: true; data: string }\n    return result.data.toUpperCase();\n  }\n\n  // result: { ok: false; error: string }\n  return `Error: ${result.error}`;\n}</code></pre>\n\n<h3>Utility Types (встроенные типовые утилиты)</h3><p>В TypeScript есть набор глобально доступных utility types для типовых преобразований (например, «сделать поля необязательными», «выбрать подмножество полей» и т.д.).</p><p>Смысл практики - повторно использовать эти утилиты там, где они выражают намерение яснее, чем ручное переписывание похожих структур.</p>\n\n<h2>Безопасные «границы» и any/never</h2><p>В типизации особенно важно аккуратно обрабатывать границы системы: JSON, внешние API, localStorage, параметры URL и любые «непроверенные» данные, потому что внутри приложения хочется опираться на гарантии типов.</p><p>TypeScript описывает специальные типы вроде <code>any</code> и <code>never</code>, причём <code>never</code> может появляться при сужении типов в ветках, которые логически недостижимы.</p>\n\n<h3>Неприятная правда про any</h3><p><code>any</code> - это аварийный выход, который отключает пользу проверки типов на конкретном участке кода, поэтому в масштабируемых проектах его стараются локализовать у границ (например, сразу после парсинга/валидации), а не «разносить» внутрь бизнес-логики.</p>\n\n<h3>Пример: проверка входных данных через narrowing</h3><p>Практика: вместо предположений о форме входного значения, сначала выполняется проверка, после чего TypeScript сможет корректнее проверить дальнейший код за счёт narrowing.</p>\n<pre><code class=\"language-ts\">function isString(x: unknown): x is string {\n  return typeof x === 'string';\n}\n\nfunction toSlug(x: unknown) {\n  if (!isString(x)) return 'invalid';\n  return x.trim().toLowerCase().replaceAll(' ', '-');\n}</code></pre>\n\n<h2>tsconfig: настройки, которые реально влияют</h2><p>Большая часть «лучших практик» в TypeScript на практике упирается в <code>tsconfig.json</code>, потому что именно настройки компилятора включают/выключают классы проверок.</p><p>Переход к более строгой конфигурации обычно обнаруживает реальные дефекты (например, неучтённые <code>undefined</code> при индексировании или неоднозначные опциональные поля) и делает поведение более предсказуемым.</p>\n\n<h3>strict</h3><p>Опция <code>strict</code> включает набор строгих проверок компилятора, которые усиливают типобезопасность и чаще выявляют потенциальные проблемы при разработке.</p>\n\n<h3>noUncheckedIndexedAccess</h3><p>Опция <code>noUncheckedIndexedAccess</code> добавляет <code>undefined</code> к типу результата при доступе по индексу, заставляя явно учитывать ситуацию «ключа/индекса нет».</p>\n<pre><code class=\"language-ts\">// При noUncheckedIndexedAccess: true\nconst arr: number[] = [];\nconst first = arr[0];\n// first: number | undefined</code></pre>\n\n<h3>exactOptionalPropertyTypes</h3><p>Опция <code>exactOptionalPropertyTypes</code> делает правила для опциональных свойств (<code>prop?</code>) более строгими и точнее различает «свойство отсутствует» и «свойство есть со значением undefined» в типовой модели.</p>\n\n<h3>noEmit (тип-чек без сборки)</h3><p>Если сборку выполняет отдельный инструмент (например, bundler), TypeScript можно использовать как проверяющий шаг, включив <code>noEmit</code>, чтобы компилятор не генерировал JS-выход.</p>\n\n<h3>isolatedModules</h3><p>Опция <code>isolatedModules</code> влияет на то, какие ограничения накладываются на код, когда каждый файл должен быть компилируем «в изоляции» (что часто важно при сборке не через <code>tsc</code>). [web:73]</p><p>В гайде по выбору опций модулей TypeScript прямо упоминает варианты вроде <code>verbatimModuleSyntax</code> или <code>isolatedModules</code> в зависимости от окружения сборки.</p>\n\n<h3>Пример tsconfig для старта</h3>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true,\n    \"noEmit\": true,\n    \"isolatedModules\": true\n  }\n}</code></pre>\n\n<h2>satisfies: проверяй форму, не теряя инференс</h2><p>В TypeScript 4.9 появился оператор <code>satisfies</code>, который позволяет проверить, что выражение соответствует заданному типу, при этом не меняя результирующий тип самого выражения.</p><p>Это особенно удобно для конфигов и таблиц соответствий, где хочется одновременно: (1) проверить форму и значения и (2) сохранить «узкие» литеральные типы для подсказок и безопасного доступа.</p>\n<pre><code class=\"language-ts\">type RouteConfig = Record&lt;string, { title: string; auth: boolean }&gt;;\n\nconst routes = {\n  home: { title: 'Home', auth: false },\n  dashboard: { title: 'Dashboard', auth: true }\n} satisfies RouteConfig;\n\n// routes сохраняет узкую структуру ключей home/dashboard,\n// но компилятор проверяет, что значения соответствуют RouteConfig.</code></pre>\n\n<h2>Линтинг TypeScript-кода</h2><p>Для больших проектов одного компилятора обычно недостаточно, потому что нужна единая дисциплина кода, и здесь часто используется typescript-eslint.</p><p>@typescript-eslint/eslint-plugin содержит «более 100» правил, которые обнаруживают нарушения best practices, потенциальные баги и/или стилистические проблемы именно в TypeScript-коде.</p>\n\n<h3>Мини-чеклист для команды</h3><ul><li>Зафиксировать стиль и ошибки через ESLint + typescript-eslint, чтобы правила работали одинаково в IDE и CI.</li><li>Включить строгие опции в tsconfig и внедрять их постепенно (по модулю/папке), чтобы улучшения были управляемыми.</li><li>У границ системы использовать runtime-проверки (narrowing) и только после них работать с данными как с типизированными."
  }
]
